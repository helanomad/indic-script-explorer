<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Indic Letter Animator + Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/opentype.js@latest/dist/opentype.min.js"></script>

  <style>
    body {
      margin: 0;
      background: #0b1220;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .wrap {
      width: min(980px, 94vw);
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 18px;
      align-items: start;
    }

    @media (max-width: 860px) {
      .wrap {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .04);
      border-radius: 16px;
      padding: 14px;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 10px;
    }

    input,
    button,
    select {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, .15);
      background: rgba(255, 255, 255, .06);
      color: #fff;
      font-size: 14px;
      outline: none;
    }

    input {
      width: 72px;
      text-align: center;
      font-size: 18px;
    }

    button {
      cursor: pointer;
    }

    button.primary {
      background: rgba(255, 255, 255, .12);
    }

    .hint {
      opacity: .75;
      font-size: 13px;
      line-height: 1.4;
    }

    canvas {
      width: 420px;
      height: 420px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .03);
      touch-action: none;
      display: block;
    }

    textarea {
      width: 100%;
      height: 260px;
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .25);
      color: #d9e6ff;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }

    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .15);
      background: rgba(255, 255, 255, .06);
      font-size: 12px;
      opacity: .9;
    }

    .letter-group label {
      white-space: nowrap;
    }

    .letter-group input {
      min-width: 0;
    }

    .row-spacer {
      flex: 1;
    }

    .letter-group button {
      white-space: nowrap;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    /* Prevent iOS zoom on input focus */
    input,
    select,
    button {
      font-size: 16px;
    }

    canvas {
      width: min(420px, 100%);
      height: auto;
      aspect-ratio: 1 / 1;
    }

    @media (max-width: 560px) {
      body {
        align-items: flex-start;
        padding: 14px 0;
      }

      .wrap {
        width: min(980px, calc(100vw - 20px));
        gap: 12px;
      }

      .panel {
        padding: 12px;
        border-radius: 14px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: center;
      }

      #modeBadge {
        grid-column: 1 / -1;
        justify-self: start;
      }

      label[for="script"],
      #script {
        grid-column: 1 / -1;
      }

      .letter-group {
        grid-column: 1 / -1;
        display: grid;
        grid-template-columns: auto 1fr auto;
        column-gap: 8px;
        align-items: center;
      }

      .letter-group input {
        width: 100%;
        min-width: 0;
      }

      .row>button,
      .row>select {
        width: 100%;
      }

      textarea {
        height: 220px;
      }

      .row-spacer {
        display: none;
      }
    }

    /* Fonts for canvas shaping */
    @font-face {
      font-family: "Hodipotha";
      src: url("../../assets/fonts/Hodipotha3.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "MartelSans-ExtraLight";
      src: url("../../assets/fonts/MartelSans-ExtraLight.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "Noto Sans Tamil";
      src: url("../../assets/fonts/NotoSansTamil.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "Noto Sans Brahmi";
      src: url("../../assets/fonts/NotoSansBrahmi.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "Adinatha";
      src: url("../../assets/fonts/Adinatha.otf") format("opentype");
      font-display: swap;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="panel">
      <div class="row">
        <span class="badge" id="modeBadge">Mode: View</span>

        <span class="row-spacer" aria-hidden="true"></span>

        <label for="script">Script</label>
        <select id="script">
          <option value="si" selected>Sinhala</option>
          <option value="deva">Devanagari</option>
          <option value="ta">Tamil</option>
          <option value="brahmi">Brahmi</option>
          <option value="tamilbrahmi">Tamil-Brahmi</option>
        </select>

        <div class="letter-group">
          <label for="ch">Letter</label>
          <input id="ch" value="‡∂Ö" maxlength="8" />
          <button id="load" class="primary">Load</button>
        </div>

        <button id="play">Play</button>
        <button id="record">Record</button>

        <button id="undo">Undo</button>
        <button id="clear">Clear</button>
        <button id="save" class="primary">Save</button>
        <button id="export">Export JSON</button>
      </div>

      <p class="hint">
        <b>View</b>: plays saved strokes with glow. <br />
        <b>Record</b>: draw on the canvas (lift finger/mouse to end a stroke), then <b>Save</b>.
        Strokes are stored in <code>localStorage</code> for now. Use <code>?ch=‡∂ö</code> in the URL if you want.
        <br />
        <b>Cluster note</b>: multi-codepoint clusters like <code>ëÄèëÅÜ</code> use browser shaping (<code>fillText</code>)
        for the guide so it matches HTML rendering (Adinatha).
      </p>

      <textarea id="out" placeholder="Exported JSON appears here..."></textarea>
    </div>

    <div class="panel" style="display:flex; justify-content:center;">
      <canvas id="cv" width="420" height="420"></canvas>
    </div>

  </div>

  <script>
    const SCRIPT_CONFIG = {
      si: {
        label: "Sinhala",
        fontUrl: "../../assets/fonts/Hodipotha3.ttf",
        fontFamily: "Hodipotha",
        defaultCh: "‡∂Ö",
        storageKey: "strokes_si_",
        fontSize: 280,
        lineWidth: 10,
        glowBlur: 10,
        totalDurationMs: 6000
      },
      deva: {
        label: "Devanagari",
        fontUrl: "../../assets/fonts/MartelSans-ExtraLight.ttf",
        fontFamily: "MartelSans-ExtraLight",
        defaultCh: "‡§Ö",
        storageKey: "strokes_deva_",
        fontSize: 280,
        lineWidth: 14,
        glowBlur: 14,
        totalDurationMs: 3200
      },
      ta: {
        label: "Tamil",
        fontUrl: "../../assets/fonts/NotoSansTamil.ttf",
        fontFamily: "Noto Sans Tamil",
        defaultCh: "‡ÆÖ",
        storageKey: "strokes_ta_",
        fontSize: 240,
        lineWidth: 18,
        glowBlur: 18,
        totalDurationMs: 3200
      },
      brahmi: {
        label: "Brahmi",
        fontUrl: "../../assets/fonts/NotoSansBrahmi.ttf",
        fontFamily: "Noto Sans Brahmi",
        defaultCh: "ëÄÖ",
        storageKey: "strokes_brahmi_",
        fontSize: 240,
        lineWidth: 20,
        glowBlur: 20,
        totalDurationMs: 3200
      },
      tamilbrahmi: {
        label: "Tamil-Brahmi",
        fontUrl: "../../assets/fonts/Adinatha.otf",
        fontFamily: "Adinatha",
        defaultCh: "ëÄÖ",
        storageKey: "strokes_tamilbrahmi_",
        fontSize: 240,
        lineWidth: 18,
        glowBlur: 18,
        totalDurationMs: 3200
      },
    };

    let FONT_SIZE = 280;
    let LINE_WIDTH = 10;
    let GLOW_BLUR = 10;
    const GUIDE_ALPHA = 0.22;

    const MIN_DIST = 4;
    const SMOOTH_WINDOW = 5;
    const SIMPLIFY_DIST = 2.2;

    let TOTAL_DURATION_MS = 6000;
    const PAUSE_MS = 300;
    const MIN_STROKE_MS = 140;
    const MAX_STROKE_MS = 1800;
    const TAIL_LEN = 10;

    const canvas = document.getElementById("cv");
    const ctx = canvas.getContext("2d");

    let fontPromise = null;
    let currentFontUrl = null;

    let guidePath2D = null;

    let mode = "view";

    let strokes = [];
    let current = null;
    let drawing = false;

    let animT = 0;
    let animLast = null;
    let animRunning = false;

    const STABILIZE = 0.35;
    const lerp = (a, b, t) => a + (b - a) * t;
    function stabilizePoint(prev, p) {
      if (!prev) return p;
      return { x: lerp(prev.x, p.x, STABILIZE), y: lerp(prev.y, p.y, STABILIZE) };
    }

    function setMode(next) {
      mode = next;
      document.getElementById("modeBadge").textContent = "Mode: " + (mode === "record" ? "Record" : "View");
    }

    function getQueryChar() {
      const p = new URLSearchParams(location.search);
      const v = p.get("ch");
      return v && v.trim() ? v.trim() : null;
    }

    function updateURLChar(ch) {
      const url = new URL(location.href);
      url.searchParams.set("ch", ch);
      history.replaceState({}, "", url);
    }

    function getPos(e) {
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top) * (canvas.height / r.height);
      return { x, y };
    }

    function smooth(points, windowSize = 5) {
      const out = [];
      const half = Math.floor(windowSize / 2);
      for (let i = 0; i < points.length; i++) {
        let sx = 0, sy = 0, c = 0;
        for (let j = -half; j <= half; j++) {
          const k = Math.min(points.length - 1, Math.max(0, i + j));
          sx += points[k].x; sy += points[k].y; c++;
        }
        out.push({ x: sx / c, y: sy / c });
      }
      return out;
    }

    function simplify(points, minDist = 3.5) {
      if (!points || points.length < 2) return points;
      const out = [points[0]];
      let last = points[0];
      for (let i = 1; i < points.length; i++) {
        const p = points[i];
        const d = Math.hypot(p.x - last.x, p.y - last.y);
        if (d >= minDist) {
          out.push(p);
          last = p;
        }
      }
      if (out.length === 1) out.push(points[points.length - 1]);
      return out;
    }

    function isCluster(text) {
      return Array.from(text).length > 1;
    }

    // ‚úÖ CRITICAL FIX: ensure the shaping font is actually loaded before fillText
    const _loadedFontKeys = new Set();
    async function ensureFontLoaded(fontFamily, fontSizePx) {
      if (!document.fonts || !fontFamily) return;
      const key = `${fontFamily}@@${fontSizePx}`;
      if (_loadedFontKeys.has(key)) return;

      try {
        // ask browser to load this face; if not loaded yet, this blocks until ready
        await document.fonts.load(`${fontSizePx}px "${fontFamily}"`);
        await document.fonts.ready;
      } catch { /* ignore */ }

      _loadedFontKeys.add(key);
    }

    function drawShapedTextGuide(ctx, canvas, text, fontFamily, guideAlpha = 0.22, fontSize = 280) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = guideAlpha;
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `${fontSize}px "${fontFamily}", serif`;
      ctx.shadowBlur = 0;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      ctx.globalAlpha = 1;
    }

    async function getFont(fontUrl) {
      if (!fontPromise || currentFontUrl !== fontUrl) {
        currentFontUrl = fontUrl;
        fontPromise = opentype.load(fontUrl);
      }
      return fontPromise;
    }

    function getFittedCenteredGlyphPath(font, glyph, canvas, baseFontSize, pad = 28) {
      let path = font.getPath(glyph, 0, 0, baseFontSize);
      let box = path.getBoundingBox();

      let w = box.x2 - box.x1;
      let h = box.y2 - box.y1;

      const maxW = canvas.width - pad * 2;
      const maxH = canvas.height - pad * 2;
      const scale = Math.min(1, maxW / w, maxH / h);

      const fontSize = baseFontSize * scale;

      path = font.getPath(glyph, 0, 0, fontSize);
      box = path.getBoundingBox();
      w = box.x2 - box.x1;
      h = box.y2 - box.y1;

      const x = (canvas.width - w) / 2 - box.x1;
      const y = (canvas.height + h) / 2 - box.y2;

      return font.getPath(glyph, x, y, fontSize);
    }

    function getScriptKey() {
      return document.getElementById("script").value;
    }

    function getCurrentCharAndCfg() {
      const scriptKey = getScriptKey();
      const cfg = SCRIPT_CONFIG[scriptKey];
      const ch = (document.getElementById("ch").value || cfg.defaultCh).trim();
      return { scriptKey, cfg, ch };
    }

    function drawGuideForCurrent() {
      const { cfg, ch } = getCurrentCharAndCfg();

      if (guidePath2D) {
        ctx.globalAlpha = GUIDE_ALPHA;
        ctx.fillStyle = "white";
        ctx.shadowBlur = 0;
        ctx.fill(guidePath2D);
        ctx.globalAlpha = 1;
        return;
      }

      if (ch && isCluster(ch)) {
        drawShapedTextGuide(ctx, canvas, ch, cfg.fontFamily || "serif", GUIDE_ALPHA, FONT_SIZE);
      }
    }

    async function loadGuide() {
      const { scriptKey, cfg, ch } = getCurrentCharAndCfg();

      FONT_SIZE = cfg.fontSize ?? FONT_SIZE;
      LINE_WIDTH = cfg.lineWidth ?? LINE_WIDTH;
      GLOW_BLUR = cfg.glowBlur ?? GLOW_BLUR;
      TOTAL_DURATION_MS = cfg.totalDurationMs ?? TOTAL_DURATION_MS;

      if (!ch) return;

      updateURLChar(ch);

      if (isCluster(ch)) {
        // ‚úÖ Ensure shaping font is ready BEFORE we draw the guide
        await ensureFontLoaded(cfg.fontFamily || "serif", FONT_SIZE);
        guidePath2D = null;
      } else {
        const font = await getFont(cfg.fontUrl);
        const glyphPath = getFittedCenteredGlyphPath(font, ch, canvas, FONT_SIZE, 28);
        guidePath2D = new Path2D(glyphPath.toPathData(2));
      }

      strokes = loadSavedStrokes(scriptKey, ch);
      redraw();
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGuideForCurrent();

      ctx.globalAlpha = 1;
      ctx.lineWidth = LINE_WIDTH;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.shadowBlur = 0;

      for (const s of strokes) {
        if (s.length < 2) continue;
        ctx.beginPath();
        ctx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) ctx.lineTo(s[i].x, s[i].y);
        ctx.stroke();
      }

      if (current && current.length >= 2) {
        ctx.beginPath();
        ctx.moveTo(current[0].x, current[0].y);
        for (let i = 1; i < current.length; i++) ctx.lineTo(current[i].x, current[i].y);
        ctx.stroke();
      }
    }

    function keyFor(scriptKey, ch) {
      return SCRIPT_CONFIG[scriptKey].storageKey + ch;
    }

    function saveStrokes(scriptKey, ch, strokes) {
      localStorage.setItem(keyFor(scriptKey, ch), JSON.stringify({ script: scriptKey, letter: ch, strokes }));
    }

    function loadSavedStrokes(scriptKey, ch) {
      const raw = localStorage.getItem(keyFor(scriptKey, ch));
      if (!raw) return [];
      try {
        const obj = JSON.parse(raw);
        return Array.isArray(obj.strokes) ? obj.strokes : [];
      } catch {
        return [];
      }
    }

    function drawPartial(points, n, glowTail = false) {
      ctx.lineWidth = LINE_WIDTH;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if (glowTail) {
        ctx.shadowColor = "rgba(255,255,255,0.95)";
        ctx.shadowBlur = GLOW_BLUR;
        ctx.strokeStyle = "rgba(255,255,255,1)";
      } else {
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(255,255,255,0.95)";
      }

      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < n; i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();
    }

    function computeStrokeDurations(strokes, totalDurationMs, pauseMs, minStrokeMs, maxStrokeMs) {
      const counts = strokes.map(s => (Array.isArray(s) ? s.length : 0));
      const totalPts = Math.max(1, counts.reduce((a, b) => a + b, 0));

      const totalPause = pauseMs * Math.max(0, strokes.length - 1);
      const drawableBudget = Math.max(250, totalDurationMs - totalPause);

      let ds = counts.map(c => (c / totalPts) * drawableBudget);
      ds = ds.map(ms => Math.min(maxStrokeMs, Math.max(minStrokeMs, ms)));
      const sum = Math.max(1, ds.reduce((a, b) => a + b, 0));
      ds = ds.map(ms => (ms / sum) * drawableBudget);

      return ds;
    }

    let strokeDurations = [];
    let pausing = false;
    let pauseStart = null;
    let strokeIndex = 0;

    function play() {
      setMode("view");

      const hasGuide = !!guidePath2D || isCluster(getCurrentCharAndCfg().ch);
      if (!hasGuide) return;
      if (!strokes.length) return;

      strokeDurations = computeStrokeDurations(
        strokes,
        TOTAL_DURATION_MS,
        PAUSE_MS,
        MIN_STROKE_MS,
        MAX_STROKE_MS
      );

      animT = 0;
      animLast = null;
      animRunning = true;
      strokeIndex = 0;

      pausing = false;
      pauseStart = null;

      requestAnimationFrame(animate);
    }

    function animate(now) {
      if (!animRunning) return;
      if (strokeIndex >= strokes.length) {
        animRunning = false;
        strokeIndex = 0;
        return;
      }

      if (pausing) {
        if (pauseStart == null) pauseStart = now;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGuideForCurrent();

        for (let k = 0; k < strokeIndex; k++) {
          const s = strokes[k];
          drawPartial(s, s.length, false);
        }

        if (now - pauseStart >= PAUSE_MS) {
          pausing = false;
          pauseStart = null;
          animT = 0;
          animLast = null;
        }

        requestAnimationFrame(animate);
        return;
      }

      if (animLast === null) animLast = now;
      const dt = now - animLast;
      animLast = now;

      const curDuration = strokeDurations[strokeIndex] || 400;

      animT += dt / curDuration;
      if (animT > 1) animT = 1;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGuideForCurrent();

      for (let k = 0; k < strokeIndex; k++) {
        const s = strokes[k];
        drawPartial(s, s.length, false);
      }

      const cur = strokes[strokeIndex];
      const n = Math.max(2, Math.floor(animT * cur.length));
      drawPartial(cur, n, false);

      const start = Math.max(0, n - TAIL_LEN);
      const tail = cur.slice(start, n);
      if (tail.length >= 2) drawPartial(tail, tail.length, true);

      if (animT >= 1) {
        strokeIndex++;
        animT = 0;
        animLast = null;

        if (strokeIndex < strokes.length) {
          pausing = true;
          pauseStart = null;
        }
      }

      requestAnimationFrame(animate);
    }

    canvas.addEventListener("pointerdown", (e) => {
      if (mode !== "record") return;

      const hasGuide = !!guidePath2D || isCluster(getCurrentCharAndCfg().ch);
      if (!hasGuide) return;

      drawing = true;
      canvas.setPointerCapture(e.pointerId);
      current = [];
      current.push(getPos(e));
      redraw();
    });

    canvas.addEventListener("pointermove", (e) => {
      if (mode !== "record") return;
      if (!drawing || !current) return;

      const raw = getPos(e);
      const last = current[current.length - 1];
      const p = stabilizePoint(last, raw);
      const d = Math.hypot(p.x - last.x, p.y - last.y);

      if (d >= MIN_DIST) current.push(p);
      redraw();
    });

    function endStroke() {
      if (mode !== "record") return;
      if (!drawing) return;

      drawing = false;
      if (current && current.length >= 2) {
        const cleaned = simplify(smooth(current, SMOOTH_WINDOW), SIMPLIFY_DIST);
        strokes.push(cleaned);
      }
      current = null;
      redraw();
    }

    canvas.addEventListener("pointerup", endStroke);
    canvas.addEventListener("pointercancel", endStroke);
    canvas.addEventListener("pointerleave", endStroke);

    document.getElementById("load").onclick = loadGuide;

    document.getElementById("play").onclick = () => {
      animRunning = false;
      strokeIndex = 0;
      play();
    };

    document.getElementById("record").onclick = () => {
      animRunning = false;
      strokeIndex = 0;
      setMode("record");
      redraw();
    };

    document.getElementById("undo").onclick = () => {
      if (mode !== "record") return;
      strokes.pop();
      redraw();
    };

    document.getElementById("clear").onclick = () => {
      if (mode !== "record") return;
      strokes = [];
      current = null;
      redraw();
    };

    document.getElementById("save").onclick = () => {
      const { scriptKey, cfg, ch } = getCurrentCharAndCfg();
      if (!ch) return;

      saveStrokes(scriptKey, ch, strokes);
      document.getElementById("out").value = `Saved ${strokes.length} stroke(s) for "${ch}" (${cfg.label}).`;
    };

    document.getElementById("export").onclick = () => {
      const { scriptKey, ch } = getCurrentCharAndCfg();
      if (!ch) return;

      const payload = { script: scriptKey, letter: ch, strokes };
      document.getElementById("out").value = JSON.stringify(payload, null, 2);
    };

    document.getElementById("ch").addEventListener("keydown", (e) => {
      if (e.key === "Enter") loadGuide();
    });

    document.getElementById("script").addEventListener("change", () => {
      const scriptKey = getScriptKey();
      const cfg = SCRIPT_CONFIG[scriptKey];

      document.getElementById("ch").value = cfg.defaultCh;

      animRunning = false;
      strokeIndex = 0;
      strokes = [];
      current = null;

      loadGuide();
    });

    document.getElementById("ch").value = getQueryChar() || "‡∂Ö";
    loadGuide();
  </script>
</body>

</html>